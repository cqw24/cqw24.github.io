---
title: 内存对齐
date: 2018-11-22 16:44:59
tags: 
categories: 计算机Tips
---

## 为何要内存对齐
<p style="text-indent: 2em">在程序员心中内存是由一个个字节组成的，但其实CPU是把内存当成一块一块的，每一块的大小可能是2、4、8、16等字节，因此CPU这读取内存的时候是一块块进行读取的，块的大小被称为**内存读取粒度**，所以当内存对齐时会优化内存读取速度，提高CPU性能。当不进行内存对齐时，CPU要对数据进行剔除合并，会对内存未对齐的寄存器进行许多额外操作，进而降低了其性能；并且内存未对齐也会影响平台的移植。因此总结原因如下：</p>

<!-- more -->

> 1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. 性能原因：经过内存对齐后，CPU的内存访问速度大大提升。

## 内存对齐的规则

### 对齐系数
* 每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的对齐系数

### 规则如下
* 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行，即**min(#pragma pack(n),数据成员自身长度)**。
* 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
* 结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。

### Win32平台下的微软C编译器(cl.exefor 80×86)的对齐策略
* 结构体变量的首地址是其最长基本类型成员的整数倍；
> 备注：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。

* 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；
> 备注:为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。

* 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节（trailing padding）。
> 备注：a、结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。
b、如果结构体内存在长度大于处理器位数的元素，那么就以处理器的倍数为对齐单位；否则，如果结构体内的元素的长度都小于处理器的倍数的时候，便以结构体里面最长的数据元素为对齐单位。

* 结构体内类型相同的连续元素将在连续的空间内，和数组一样。

<font color=#FF0000>注：</font>上述对齐规则摘自百度百科词条

